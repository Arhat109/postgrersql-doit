## Решение:
Создаем 2 скрипта term1.sql, term2.sql для запуска пары сессий с postgres и формируем run.sh, создающий БД и 
запускающий term1 как фоновый процесс, и с небольшой паузой запускающий term2.

## Результат:
~$ ./run.sh

### создание БД первая часть, исполнячется create.sql
```
Пароль: 
DROP DATABASE
DROP ROLE
CREATE ROLE
ALTER ROLE
CREATE DATABASE
GRANT
GRANT
Пароль: 
SSL-соединение (протокол: TLSv1.3, шифр: TLS_AES_256_GCM_SHA384, сжатие: выкл.)
Вы подключены к базе данных "hw4" как пользователь "postgres".
SET
CREATE TABLE
INSERT 0 2
```

### Запуск скрипта term1.sql как фонового процесса:
```
start term1
Пароль: 
Пароль: 
Вы подключены к базе данных "hw4" как пользователь "postgres".
SET
BEGIN
UPDATE 1
```

### После паузы запуск скрипта term2.sql как команды:
```
start term2
Пароль: 
Пароль: 
SSL-соединение (протокол: TLSv1.3, шифр: TLS_AES_256_GCM_SHA384, сжатие: выкл.)
Вы подключены к базе данных "hw4" как пользователь "postgres".
SET
BEGIN
UPDATE 1
```

### Вывод фонового процесса: начато ожидание:
```
 pg_sleep 
----------
 
(1 строка)
```

### Ошибка при попытке выполнить вторую часть транзакции из скрипта term1.sql:
```
psql:term1.sql:12: ОШИБКА:  обнаружена взаимоблокировка
ПОДРОБНОСТИ:  Процесс 40508 ожидает в режиме ShareLock блокировку "транзакция 1055284"; заблокирован процессом 40535.
Процесс 40535 ожидает в режиме ShareLock блокировку "транзакция 1055283"; заблокирован процессом 40508.
ПОДСКАЗКА:  Подробности запроса смотрите в протоколе сервера.
КОНТЕКСТ:  при изменении кортежа (0,2) в отношении "accounts"
UPDATE 1
ROLLBACK
COMMIT
end term2
```

Откат транзакции №1 т.к. deadlock был обнаружен в ней(?).
